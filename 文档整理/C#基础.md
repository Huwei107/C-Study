## 1. 类和对象的关系
类：是对一类“事物”的属性与行为的抽象
对象：是一个具体的概念，通过new创建
程序运行在内存中（随机存储器）
**********************************************************************************************************************************************************
## 2.类中字段、属性、变量、方法、参数的区别
1. 字段、属性、方法写在类里，参数、变量写在方法中
2. 属性get，set，比较灵活
**********************************************************************************************************************************************************
## 3.类型
1. 值类型在栈中（连续的），引用类型在堆中（块）
2. 预定义：
  1. 值类型：int，char，double，bool
  2. 引用类型：string
3. 自定义：
  1. 值类型：Struct，Enum

  2. 引用类型：Class，Interface
4. C#程序就是一组类型声明
**********************************************************************************************************************************************************
## 4.类型转换：C#程序就是一组类型声明
1. 显式转换：大转小（可能丢失精度）
2. 隐式转换：小转大
3. 方法转换：Convert，tryParse（强制转换）
4. 自定义转换：AutoMapper对象映射
**********************************************************************************************************************************************************
## 5.操作符as和is
1. AS操作符：用于类型检查和转换（针对引用类型，成功返回对象，失败返回null）
2. IS操作符：用于检查一个类型是否是某一个类型（针对所有类型，是返回true，否返回false）
**********************************************************************************************************************************************************
## 6.装箱和拆箱
1. 装箱：值类型到引用类型
2. 拆箱：引用类型到值类型
3. 避免频繁的装箱和拆箱，使用泛型或值类型解决这个问题
**********************************************************************************************************************************************************
## 7.常量和字段
1. 常量：存储不变的数据，声明时必须赋值并且之后不可更改
2. 字段：存储变化的数据
**********************************************************************************************************************************************************
## 8.构造方法
1. 作用：初始化数据，执行必要的操作，验证对象状态，防止对象创建（私有构造函数）
**********************************************************************************************************************************************************
## 9.栈和堆
1. 栈：存放值类型和传递给方法的参数，由GC释放
2. 堆：存放引用类型的数据，引用类型的地址是存放在栈中的，引用类型包含值类型时，也都是存放在堆中的
**********************************************************************************************************************************************************
## 10.实参和形参
1. 实参：方法调用时使用
2. 形参：方法定义时使用（值类型是在栈中重新分配一个空间，引用类型是重新复制一个地址，但指向同一个空间），ref和out
**********************************************************************************************************************************************************
## 11.重载方法
1. 定义：方法的参数的个数、类型和顺序不一致，方法名相同
**********************************************************************************************************************************************************
## 12.方法
1. 本质：存储执行代码的
2. 栈帧(stack frame)：方法调用时保存方法相关数据的一块栈空间
**********************************************************************************************************************************************************
## 13.类成员
1. 实例成员：每次实例化分配新的堆空间
2. 静态成员：不在堆里，在另外的静态区域
3. 常量：必须初始化，编译时就直接赋值，没有占用内存空间
**********************************************************************************************************************************************************
## 14.静态构造方法
1. 在使用任何其他静态成员和创建类的任何实例之前运行
2. 方法名和类名相同
3. 只能有一个，不能带参数
4. 不能访问实例方法
5. 不能手动调用，系统自动调用
6. 作用：初始化静态成员
**********************************************************************************************************************************************************
## 15.readonly和const
区别：
     1. readonly可以在字段声明中、类的任何构造函数中；const只能在字段声明中初始化
     2. readonly可以在运行时决定值；const必须在编译时绝对值
     3. readonly可以是静态字段也可以是实例字段；const总是静态的
     4. readonly有内存位置；const在内存中没有存储位置
**********************************************************************************************************************************************************
## 16.分部类
定义：被partial修饰的类，实现代码的重用（比如winform的窗体类）
**********************************************************************************************************************************************************
## 17.继承（类的继承性能不是很好）
1. 所有类型都继承自object，子类（派生类），父类（基类）
2. 子类屏蔽父类的同名方法，显示屏蔽就是方法的修饰符前加new
**********************************************************************************************************************************************************
## 18.虚方法和重写方法
**********************************************************************************************************************************************************
## 19.base和this关键字
**********************************************************************************************************************************************************
## 20.访问修饰符
1. protected：用于继承关系之间
2. internal：用于程序集之间
**********************************************************************************************************************************************************
## 21.抽象类和抽象成员
抽象类：只能作为其他类的基类存在
1. 不能创建抽象类的实例
2. 使用abstract修饰符声明
抽象成员：方法、属性、事件、索引器
1. 没有实现
2. 必须被重写
**********************************************************************************************************************************************************
## 22.密封类
1. 只能做独立的类，不能做基类（不能被继承）
2. 使用sealed修饰符声明
**********************************************************************************************************************************************************
## 23.静态类
作用：用于存放不受实例数据影响的数据和函数
1. 使用static修饰符声明
2. 所有成员都必须是静态的
3. 只有一个静态构造函数
4. 隐式密封的，不能被继承
使用场景：方便的访问共享成员而不用创建实例
1. 过多的静态类的使用会对程序性能或内存空间有一些影响，因为需要为静态类分配一定的空间
2. 静态类在第一次使用时初始化，不使用就不初始化
**********************************************************************************************************************************************************
## 24.结构类型struct
1. 值类型注意拆装箱问题
2. 隐式密封(sealed)，不能被继承，不使用protected/internal/abstract/virtual关键字
3. 与类比赋值不同
4. 可以有实例构造函数和静态构造函数，没有析构函数(会自己释放)
5. 不能直接初始化，必须有一个实例的构造函数
**********************************************************************************************************************************************************
## 25.委托
定义：保存方法的引用类型，是一种类型可以实例化
# 多播委托
定义：在一个委托中保存多个方法
**********************************************************************************************************************************************************
## 26.泛型
定义：一种通用类型，可以定义没有明确类型的成员
# 泛型委托Func（有返回值）
# 泛型委托Action（无返回值）
# 泛型约束
  1. 默认构造函数约束：必须放最后，（抽象类、接口、密封类没有默认构造函数）
  2. 值类型约束
  3. 多参数约束
  4. 多重约束
# 协变和逆变（扩大泛型的使用范围）
  1. 协变：在泛型中子类变量可以赋值给父类变量，out
  2. 逆变：在泛型中父类作为方法参数、父类变量赋值给子类时，in
**********************************************************************************************************************************************************
## 27.回调和委托
**********************************************************************************************************************************************************
## 28.委托与事件
1. 委托使用流程：定义=》实例化=》调用

# 区别：
  1. 定义位置不同：委托是类型，事件是类型成员
  2. 事件只能由所在类成员调用
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
