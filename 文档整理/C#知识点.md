## 1.DataSet和SqlDataReader
Ⅰ、DataSet是把数据读出，缓存在内存中。缺点：对内存的占用较高
Ⅱ、SqlDataRead优点：读取数据非常快
Ⅲ、读取大量数据,对返回数据不做大量处理用SqlDataReader.对返回数据大量处理用DataSet比较合适.对SqlDataReader和Dataset的选择取决于程序功能的实现
**********************************************************************************************************************************************************
## 2.装箱和拆箱（强制类型转换）
装箱：将值类型转换为引用类型称为装箱
拆箱：将引用类型转换为值类型称为拆箱
Ⅰ、普遍的场景是调用一个含类型为Objcet的参数的方法，该Object可支持任意类型，以便通用。当你需要将一个值类型传入时，需要装箱。
Ⅱ、一个非泛型的容器，同样是为了保证通用，而将元素类型定义为Objcet。于是，要将值类型数据加入容器，需要装箱。
Ⅲ、装箱时生成的是全新的引用对象，这就会有时间损耗，造成效率降低，所以应该尽量避免装箱。前面提到的两种情况，都可以避免，在第1中情况下，可以通过重载函数来避免，而第2种情况则可以通过泛型来避免
**********************************************************************************************************************************************************
## 3.DataReader和DataAdapter
Ⅰ、使用DataReader需要对集合（list）配合使用，封装较为麻烦，但对集合作为数据源能够体现更好的面向对象特性
Ⅱ、DataAdapter与DataSet配合使用，后台无需单独封装，编写非常简单，但不能更好的体现面向对象编程特性
**********************************************************************************************************************************************************
## 4.垃圾回收机制(GC)
Ⅰ、C#内置的自动垃圾回收GC，不需要担心内存溢出的问题 变量失去引用后 GC会自动回收，但不包括数据流和一些数据库的连接，这就需要我们手动的释放资源
Ⅱ、GC只会回收堆的内存 ，而值类型在栈中的使用完后马上就会给释放
Ⅲ、除非马上需要进行非常消耗内存的操作 其他情况尽量不要调用GC.Collect()，会影响性能
**********************************************************************************************************************************************************
## 5.class和struct有什么区别？
Ⅰ、class是面向对象编程的基本概念，是一种引用类型，一种自定义数据结构类型，通常包含字段、属性、方法、构造函数等
Ⅱ、struct是一种值类型，用于将一组相关的变量组织为一个单一的变量实体
Ⅲ、当你实例化一个 class，它将创建在【堆】上。而你实例化一个 struct，它将创建在【栈】上
**********************************************************************************************************************************************************
## 6.string和stringbuild区别是什么？
Ⅰ、String本身是不可改变的，它只能赋值一次，每一次内容发生改变，都会生成一个新的对象，然后原有的对象引用新的对象，而每一次生成新对象都会对系统性能产生影响（循环中拼接sql语句时，尽量不用string）
Ⅱ、StringBuilder类则不同，每次操作都是对自身对象进行操作，而不是生成新的对象，其所占空间会随着内容的增加而扩充，这样，在做大量的修改操作时，不会因生成大量匿名对象而影响系统性能
**********************************************************************************************************************************************************
## 7.var关键字
Ⅰ、var只能定义局部变量，不能定义成员变量
Ⅱ、var定义的时候必须同时完成初始化，不能使用var定义变量为null
Ⅲ、var本身不是一个新类型，只是用来修饰一个可以推断出具体类型的局部变量
**********************************************************************************************************************************************************
## 8.匿名类
Ⅰ、直接使用new关键字创建对象，使用var定义对象变量
Ⅱ、不需要提前编写类的成员，只能添加类的属性
**********************************************************************************************************************************************************
## 9.扩展方法
Ⅰ、扩展方法必须定义在静态类中，扩展方法本身也是静态方法
Ⅱ、扩展方法和对应的类位于不同的命名空间，使用时应该引入扩展方法所在类的命名空间
Ⅲ、当类本身的方法与扩展方法重名时，优先调用类本身的方法
Ⅳ、扩展方法不要过多使用
**********************************************************************************************************************************************************
## 10.lambda与匿名方法比较
Ⅰ、lambda表达式本身就是匿名方法
Ⅱ、lambda表达式的参数允许不指明参数类型，而匿名方法的参数必须明确指明参数类型
Ⅲ、lambda表达式允许方法体由单一表达式构成，而匿名方法不允许
**********************************************************************************************************************************************************
## 11.count(*) 和 count(1)和count(指定字段)
  1. 执行效果上 ：
      count(*)包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL
      count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL
      count(字段)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计
  2. 执行效率上：
      列名为主键，count(指定字段)会比count(1)快
      列名不为主键，count(1)会比count(指定字段)快
      如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）
      如果有主键，则 select count（主键）的执行效率是最优的
      如果表只有一个字段，则 select count（*）最优。
**********************************************************************************************************************************************************
12.DDD领域设计、grpc、数据结构
**********************************************************************************************************************************************************
## 13.sqlserver 分页
  1、offset /fetch next关键字，select * from tb_user order by uid offset 10 rows fetch next 10 rows only ;
     offset 10 rows ，将前10条记录舍去，fetch next 10 rows only ，向后再读取10条数据。
  2、利用max（主键），主键必须是自增int类型
  3、利用row_number关键字 row_number() over(order by 主键 asc)
**********************************************************************************************************************************************************
## 14.缓存
  1. Memory Caching
  2. Redis
  3. SqlServer
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**********************************************************************************************************************************************************
